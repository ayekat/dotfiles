#!/usr/bin/env sh
# Set and get custom environment variables dynamically. This means the variable
# datas are not stored in traditional variables, but instead are written and
# retrieved from files. This allows environment variable manipulation accross
# processes.
# SECURITY WARNING: Please note that this may be abused, so do not use this for
# critical programmes.
# Written by ayekat on a cold saturday morning in october 2013.

envdir="$0".d
appname="$(basename "$0")"

dynenv_set() {
	# fuckery for multi-line values:
	envline="$(echo "$1" | head -n 1)"
	envtail="$(echo "$1" | tail -n +2)"
	envkey="$(echo "$envline" | cut -d '=' -f 1)"
	envval="$(echo "$envline" | cut -d '=' -f 2)"
	envfile="$envdir"/"$envkey"
	printf "$envval" > "$envfile"
	[ -n "$envtail" ] && echo >> "$envfile"
	printf "$envtail" >> "$envfile"
}

dynenv_get() {
	[ -f "$envdir"/"$1" ] && cat "$envdir"/"$1"
}

dynenv_list() {
	[ $(ls "$envdir" | wc -l) -eq 0 ] && return
	for i in "$envdir"/*; do
		printf "%s=%s\n" "$(basename "$i")" "$(cat "$i")"
		[ $? -ne 0 ] && error=1
	done
	[ $error ] && false || true
}

dynenv_unset() {
	[ -f "$envdir"/"$1" ] && rm "$envdir"/"$1"
}

dynenv_help() {
	printf "%s unset \033[4mkey\033[0m " "$appname"
	printf "| \033[4mkey\033[0m[=\033[4mvalue\033[0m]\n"
}

# assure that environment directory exists:
if [ ! -d "$envdir" ]; then
	mkdir "$envdir" || exit 1
	chmod 700 "$envdir"
fi

# check if there is an argument, otherwise list:
if [ $# -eq 0 ]; then
	dynenv_list
	exit $?
fi

# check for unset:
if [ "$1" = 'unset' ]; then
	if [ $# -ne 2 ]; then
		dynenv_help
		exit 2
	fi
	dynenv_unset "$2"
	exit $?
fi

# check syntax:
if [ $# -ne 1 ]; then
	dynenv_help
	exit 2
fi

# set/get:
if [ $(echo "$1" | grep '=' | wc -l) -eq 1 ]; then
	dynenv_set "$1"
	exit $?
else
	dynenv_get "$1"
fi

