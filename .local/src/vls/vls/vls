#!/bin/sh
# This script handles a VLS (Virtual Local Server), a headless qemu VM hooked up
# to a VDE switch.
# It assumes that dnsmasq is already running (see vls.service).

vls_die() {
	echo "ERROR: $@" >&2
	exit 1
}

vls_check_root() {
	test $(id -u) -eq 0 || vls_die "$0 requires you to be root"
}

vls_help() {
	echo "Usage: $0 start|stop"
	exit 1
}

vls_pre_stop() {
	vls_interrupted=1
}

vls_start() {
	# default VM MAC address:
	vls_mac='52:54:00:12:34:56'

	# dnsmasq config:
	echo "Getting dnsmasq configuration ..."
	dnsmasq_conf='/etc/dnsmasq.conf'
	if [ ! -e $dnsmasq_conf ]; then
		echo "$dnsmasq_conf not found, using default MAC address" >&2
	else
		vls_mac_tmp="$(grep '^dhcp-host=' "$dnsmasq_conf" | head -n 1 | \
		               sed -e 's/^dhcp-host=//g' | cut -d ',' -f 1)"
		vls_mac="$vls_mac_tmp"
	fi

	# VLS config:
	echo "Getting VLS configuration ..."
	test -e $vls_conffile || vls_die "$vls_conffile not found"
	. $vls_conffile
	test -n "$parttev" || vls_die 'Partition device [partdev] not specified'
	test -n "$mbrfile" || vls_die 'Path to MBR file [mbrfile] not specified'
	test -n "$raiddev" || vls_die 'RAID device [raiddev] not specified'

	# RAID devices:
	echo "Checking devices for RAID setup ..."
	test -e $partdev || vls_die "System partition $partdev not found"
	test -e $mbrfile || vls_die "MBR file $mbrfile not found"
	test -e $raiddev && vls_die "$raiddev already exists"

	# catch interrupts, as from here on we will change the system state:
	trap vls_pre_stop SIGINT
	trap vls_pre_stop SIGTERM
	trap vls_pre_stop SIGHUP

	# build RAID device:
	echo "Building RAID device ..."
	loopdev=$(losetup -f)
	test -n "$loopdev" || vls_die "No free loop device"
	losetup $loopdev $mbrfile || vls_die "losetup failed"
	mdadm --build --verbose $raiddev \
	      --level=linear --raid-devices=2 $loopdev $partdev
	if [ $? -ne 0 ]; then
		losetup -d $loopdev
		vls_die "mdadm failed"
	fi

	# build runtime files:
	echo "Creating runtime directory ..."
	mkdir -p $vls_runpath

	# launch VM if not interrupted:
	if [ $vls_interrupted -eq 1 ]; then
		echo 'Received shutdown signal, not starting VLS'
	else
		echo "Launching VLS ..."
		qemu-system-x86_64 -enable-kvm -cpu host -smp 4 \
		                   -m 4096 \
		                   -drive file=$raiddev \
		                   -net nic,model=virtio,macaddr=$vls_mac -net vde \
		                   -nographic -vnc :7 \
		                   -monitor unix:$vls_sockfile,server,nowait &
		qemu_pid=$!
		echo "qemu_pid=$qemu_pid" > $vls_lockfile
		trap vls_stop SIGINT
		trap vls_stop SIGTERM
		trap vls_stop SIGHUP
		wait $qemu_pid
	fi

	# nuke socket:
	echo "Nuking runtime files ..."
	rm -rf $vls_runpath

	# nuke RAID device:
	echo "Nuking RAID device ..."
	mdadm --stop $raiddev
	losetup -d $loopdev
}

vls_stop() {
	echo 'Stopping the VLS ...'
	if [ -e $vls_sockfile ] && [ -n "$(which -a socat)" ]; then
		echo 'system_powerdown' | socat stdio UNIX-CONNECT:$vls_sockfile
	elif [ -e $vls_lockfile ]; then
		echo 'socat: command not found, killing machine'
		. $vls_lockfile
		kill $qemu_pid
	fi
	# else the VLS is not running and we don't do anything
}

vls_runpath=/run/vls
vls_lockfile=$vls_runpath/vls.lock
vls_sockfile=$vls_runpath/vls.sock
vls_interrupted=0
vls_conffile=/etc/vls.conf

case "$1" in
	start) vls_check_root && vls_start ;;
	stop) vls_check_root && vls_stop ;;
	*) vls_help ;;
esac
